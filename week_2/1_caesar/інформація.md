Кажуть, що Цезар (так, той самий Цезар) зашифровував усі конфіденційні повідомлення 
(тобто змінював їх таким чином, щоб можна було відновити оригінал) шляхом зсуву кожної букви на кілька кроків. 
Наприклад, він міг написати A як B, B як C, C як D ... Z як A. А отже, щоб сказати комусь HELLO, 
Цезар міг написати IFMMP. Після отримання такого повідомлення від Цезаря, 
отримувачі повинні були «розшифрувати» повідомлення шляхом зсуву літер 
у зворотньому напрямку на таку саму кількість кроків.

Секретність такої «криптосистеми» полягала у тому, що тільки Цезар і отримувач повідомлення 
знали цей секрет – кількість кроків, на яку Цезар зсунув літери (наприклад, 1). 
За нинішніми стандартами, все це не так вже й безпечно, 
але якщо ви – перша людина у світі, яка займається подібними речами, ще й як безпечно!

Незашифрований текст зазвичай називають звичайний текст. 
Зашифрований текст зазвичай так і називають зашифрований текст. 
Секретна інформація, що використовується при шифруванні, називається ключем.

На рисунку нижче зображено, як слово HELLO із використанням ключа 1 шифрується у IFMMP:

```
---------------------------------------------
| звичайний текст       | H | E | L | L | O |
---------------------------------------------
| + ключ                | 1 | 1 | 1 | 1 | 1 |
---------------------------------------------
| = шифрований текст    | I | F | M | M | P |
---------------------------------------------
```

Якщо говорити загально, алгоритм Цезаря (тобто шифр Цезаря) шифрує повідомлення шляхом 
«обертання» кожної букви на k позицій. Формальніше, якщо p – якийсь звичайний текст (незашифрованне повідомлення), 
pi – це iий символ у p, а k – секретний ключ (тобто невід'ємне ціле число), 
тоді кожна буква ci у зашифрованному тексті c, обраховується так:

` ci = (pi + k) % 26 `

де `%26` означає «залишок від ділення на 26». 

Ця формула, мабуть, робить так, що шифр видається складнішим, ніж насправді, 
але це лише лаконічна форма точного вираження суті алгоритму. 
Насправді, задля прикладу, подумайте про А (або а) як про В (або b) як про 1, і так далі, 
H (або h) як про 7, I (або i) як про 8 і так далі, а Z (або z) як про 25. 
Уявімо, що Цезар хотів сказати «Hi» комусь конфіденційно, використвавши цього разу ключ k 3. 
Тож його звичайний текст p – це «Hi», у цьому випадку перша літера його звичайного тексту p0 – це H (вона ж 7), 
а друга літера p1 – це i (вона ж 8). Перша літера зашифрованого тексту c0, таким чином K, а друга - c1, відповідно L. Розумієте чому?

Давайте напишемо програму під назвою caesar, яка дозволить вам зашифрувати повідомлення шифром Цезаря. 
Під час запуску програми користувачем, він має обрати за допомогою аргументів командного рядка, 
яким буде ключ у секретному повідомленні, яке він введе під час роботи програми. Не треба очікувати, 
що ключем обов’язково буде число, але можна вважати, що якщо це число, то це буде додатне ціле число.

Ось кілька прикладів очікуваної роботи цієї програми. Наприклад, якщо користувач вводить ключ 1 та текст HELLO:
```
$ ./caesar 1
plaintext:  HELLO
ciphertext: IFMMP
```
Ось так може працювати програма, якщо користувач введе ключ 13 та текст hello, world:
```
$ ./caesar 13
plaintext:  hello, world
ciphertext: uryyb, jbeyq
```
Зверніть увагу, що ані кома, ані пробіл не були «змінені» шифром. Він змінює виключно літерні символи!

Розглянемо ще? Ось так працюватиме програма, якщо користувач введе ключ 13 ще раз, але для складнішого тексту:
```
$ ./caesar 13
plaintext:  be sure to drink your Ovaltine
ciphertext: or fher gb qevax lbhe Binygvar
```

Зверніть увагу, що регістр символів оригінального повідомлення збережено. Літери у нижньому регістрі залишились маленькими, а літери у верхньому регістрі лишились великими.

А якщо користувач не хоче співпрацювати?
```
$ ./caesar HELLO
Usage: ./caesar key
```
Або зовсім не хоче співпрацювати?
```
$ ./caesar
Usage: ./caesar key
```
Або навіть…
```
$ ./caesar 1 2 3
Usage: ./caesar key
```

Посилання на курс: https://courses.prometheus.org.ua/courses/course-v1:Prometheus+CS50+2019_T1/course/
